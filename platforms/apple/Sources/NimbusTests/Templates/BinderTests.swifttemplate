<%- includeFile("../../Nimbus/Templates/Config.swift") -%>
<%- includeFile("../../Nimbus/Templates/Utils.swift") -%>
//
// Copyright (c) 2019, Salesforce.com, inc.
// All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
// For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
//

import XCTest

@testable import Nimbus

// repetitive tests are repetitive...
// swiftlint:disable type_body_length file_length

class BinderTests: XCTestCase {
    let binder = TestBinder()
<%_  for (index, arity) in arities.enumerated() { -%>
<%_     if index == 0 { _%>
    func testBindNullaryNoReturn() {
        binder.bind(BindTarget.nullaryNoReturn, as: "")
        _ = try? binder.callable?.call(args: [])
        XCTAssert(binder.target.called)
    }

    func testBindNullaryNoReturnThrows() {
        binder.bind(BindTarget.nullaryNoReturnThrows, as: "")
        XCTAssertThrowsError(try binder.callable?.call(args: []))
        XCTAssert(binder.target.called)
    }

    func testBindNullaryWithReturn() {
        binder.bind(BindTarget.nullaryWithReturn, as: "")
        let value = try? binder.callable?.call(args: []) as? String
        XCTAssert(binder.target.called)
        XCTAssertEqual(value, .some("value"))
    }

    func testBindNullaryWithReturnThrows() {
        binder.bind(BindTarget.nullaryWithReturnThrows, as: "")
        XCTAssertThrowsError(try binder.callable?.call(args: []))
        XCTAssert(binder.target.called)
    }
<%_      } else { _%>
    func testBind<%= arity.name.capitalizingFirstLetter() %>NoReturn() {
        binder.bind(BindTarget.<%= arity.name %>NoReturn, as: "")
        _ = try? binder.callable?.call(args: [<%= arities.takeAsString(count: index) %>])
        XCTAssert(binder.target.called)
    }

    func testBind<%= arity.name.capitalizingFirstLetter() %>NoReturnThrows() {
        binder.bind(BindTarget.<%= arity.name %>NoReturnThrows, as: "")
        XCTAssertThrowsError(try binder.callable?.call(args: [<%= arities.takeAsString(count: index) %>]))
        XCTAssert(binder.target.called)
    }

    func testBind<%= arity.name.capitalizingFirstLetter() %>WithReturn() throws {
        binder.bind(BindTarget.<%= arity.name %>WithReturn, as: "")
        let value = try binder.callable?.call(args: [<%= arities.takeAsString(count: index) %>]) as? Int
        XCTAssert(binder.target.called)
        XCTAssertEqual(value, .some(<%= arities.takeAsSum(count: index)%>))
    }

    func testBind<%= arity.name.capitalizingFirstLetter() %>WithReturnThrows() throws {
        binder.bind(BindTarget.<%= arity.name %>WithReturnThrows, as: "")
        XCTAssertThrowsError(try binder.callable?.call(args: [<%= arities.takeAsString(count: index) %>]))
        XCTAssert(binder.target.called)
    }

    func testBind<%= arity.name.capitalizingFirstLetter() %>WithUnaryCallback() {
        binder.bind(BindTarget.<%= arity.name %>WithUnaryCallback, as: "")
        let expecter = expectation(description: "callback")
        var result: Int?
        let callback: BindTarget.UnaryCallback = { value in
            result = value
            expecter.fulfill()
        }
        _ = try? binder.callable?.call(args: [<%= arities.takeAndMakeParamsWithCallable(count: index)%>])
        wait(for: [expecter], timeout: 5)
        XCTAssert(binder.target.called)
        XCTAssertEqual(result, .some(<%if index > 2 { %><%= arities.takeAsSum(count: index - 1) %><% } else { %><%= arities.takeAsSum(count: 1) %><% } %>))
    }

    func testBind<%= arity.name.capitalizingFirstLetter() %>WithUnaryCallbackThrows() {
        binder.bind(BindTarget.<%= arity.name %>WithUnaryCallbackThrows, as: "")
        let expecter = expectation(description: "callback")
        let callback: BindTarget.UnaryCallback = { value in
            expecter.fulfill()
        }
        XCTAssertThrowsError(try binder.callable?.call(args: [<%= arities.takeAndMakeParamsWithCallable(count: index)%>]))
        wait(for: [expecter], timeout: 5)
        XCTAssert(binder.target.called)
    }

    func testBind<%= arity.name.capitalizingFirstLetter() %>WithBinaryCallback() {
        binder.bind(BindTarget.<%= arity.name %>WithBinaryCallback, as: "")
        let expecter = expectation(description: "callback")
        var result: Int?
        let callback: BindTarget.BinaryCallback = { value1, value2 in
            result = value1 + value2
            expecter.fulfill()
        }
        _ = try? binder.callable?.call(args: [<%= arities.takeAndMakeParamsWithCallable(count: index)%>])
        wait(for: [expecter], timeout: 5)
        XCTAssert(binder.target.called)
        XCTAssertEqual(result, .some(<%if index > 2 { %><%= arities.takeAsSum(count: index - 1) %><% } else { %><%= arities.takeAsSum(count: 2) %><% } %>))
    }

    func testBind<%= arity.name.capitalizingFirstLetter() %>WithBinaryCallbackThrows() {
        binder.bind(BindTarget.<%= arity.name %>WithBinaryCallbackThrows, as: "")
        let expecter = expectation(description: "callback")
        let callback: BindTarget.BinaryCallback = { value1, value2 in
            expecter.fulfill()
        }
        XCTAssertThrowsError(try binder.callable?.call(args: [<%= arities.takeAndMakeParamsWithCallable(count: index)%>]))
        wait(for: [expecter], timeout: 5)
        XCTAssert(binder.target.called)
    }
<%_     } -%>
<%_ } -%>
}

enum BindError: Error {
    case boundMethodThrew
}

class BindTarget {
    private(set) var called = false

    typealias UnaryCallback = (Int) -> Void
    typealias BinaryCallback = (Int, Int) -> Void
<%_  for (index, arity) in arities.enumerated() { -%>
<%_     if index == 0 { _%>
    func nullaryNoReturn() {
        called = true
    }

    func nullaryNoReturnThrows() throws {
        called = true
        throw BindError.boundMethodThrew
    }

    func nullaryWithReturn() -> String {
        called = true
        return "value"
    }

    func nullaryWithReturnThrows() throws -> String {
        called = true
        throw BindError.boundMethodThrew
    }
<%     } else { -%>

    func <%= arity.name %>NoReturn(<%= getCommaSeparatedString(count: index, formattingPurpose: .forMethodArgsAsIntDecl) %>) {
        called = true
    }

    func <%= arity.name %>NoReturnThrows(<%= getCommaSeparatedString(count: index, formattingPurpose: .forMethodArgsAsIntDecl) %>) throws {
        called = true
        throw BindError.boundMethodThrew
    }

    func <%= arity.name %>WithReturn(<%= getCommaSeparatedString(count: index, formattingPurpose: .forMethodArgsAsIntDecl) %>) -> Int {
        called = true
        return <%= getCommaSeparatedString(count: index, formattingPurpose: .forArgsSum)%>
    }

    func <%= arity.name %>WithReturnThrows(<%= getCommaSeparatedString(count: index, formattingPurpose: .forMethodArgsAsIntDecl) %>) throws -> Int {
        called = true
        throw BindError.boundMethodThrew
    }

    func <%= arity.name %>WithUnaryCallback(<% if index > 1 { %><%= getCommaSeparatedString(count: index - 1, formattingPurpose: .forMethodArgsAsIntDecl) %>, <% } %>callback: @escaping UnaryCallback) {
        called = true
        callback(<% if index > 1 { %><%= arities.getCallbackArgsForUnaryCallback(count: index - 1) %><% } else { %><%= arities.getCallbackArgsForUnaryCallback(count: index) %><% } %>)
    }

    func <%= arity.name %>WithUnaryCallbackThrows(<% if index > 1 { %><%= getCommaSeparatedString(count: index - 1, formattingPurpose: .forMethodArgsAsIntDecl) %>, <% } %>callback: @escaping UnaryCallback) throws {
        called = true
        callback(<% if index > 1 { %><%= arities.getCallbackArgsForUnaryCallback(count: index - 1) %><% } else { %><%= arities.getCallbackArgsForUnaryCallback(count: index) %><% } %>)
        throw BindError.boundMethodThrew
    }

    func <%= arity.name %>WithBinaryCallback(<% if index > 1 { %><%= getCommaSeparatedString(count: index - 1, formattingPurpose: .forMethodArgsAsIntDecl) %>, <% } %>callback: @escaping BinaryCallback) {
        called = true
        callback(<%= arities.getCallbackArgsForBinaryCallback(count: index) %>)
    }

    func <%= arity.name %>WithBinaryCallbackThrows(<% if index > 1 { %><%= getCommaSeparatedString(count: index - 1, formattingPurpose: .forMethodArgsAsIntDecl) %>, <% } %>callback: @escaping BinaryCallback) throws {
        called = true
        callback(<%= arities.getCallbackArgsForBinaryCallback(count: index) %>)
        throw BindError.boundMethodThrew
    }
<%      } -%>
<%  } -%>
}

class TestBinder: Binder {
    typealias Target = BindTarget
    let target = BindTarget()

    init() {}

    func bind(_ callable: Callable, as name: String) {
        self.callable = callable
    }

    public var callable: Callable?
}
